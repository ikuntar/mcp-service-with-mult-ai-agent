# 06_æ’ä»¶å¼€å‘æŒ‡å—

## ğŸ¯ å­¦ä¹ ç›®æ ‡
- ç†è§£æ’ä»¶ç³»ç»Ÿæ¶æ„
- æŒæ¡æ’ä»¶å¼€å‘æµç¨‹
- å­¦ä¼šæ’ä»¶æ³¨å†Œå’Œä½¿ç”¨

## ğŸ”Œ æ’ä»¶ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒæ¦‚å¿µ

æ’ä»¶æ˜¯æ¡†æ¶çš„æ‰©å±•æœºåˆ¶ï¼Œå…è®¸åŠ¨æ€æ·»åŠ æ–°åŠŸèƒ½ï¼š

```
æ’ä»¶ â†’ å·¥å…·é›†åˆ â†’ å®¹å™¨é›†æˆ â†’ æƒé™è¿‡æ»¤
```

### æ’ä»¶æ¥å£

```typescript
interface MCPPlugin {
  name: string;           // æ’ä»¶åç§°
  version: string;        // æ’ä»¶ç‰ˆæœ¬
  description: string;    // æ’ä»¶æè¿°
  getTools?(): Tool[];    // è·å–å·¥å…·åˆ—è¡¨
  initialize?(config: any): Promise<void>;  // åˆå§‹åŒ–
  cleanup?(): Promise<void>;  // æ¸…ç†
}
```

## ğŸš€ åˆ›å»ºæ’ä»¶

### 1. åŸºç¡€æ’ä»¶ç»“æ„

```typescript
// src/plugins/my-plugin.ts
import type { MCPPlugin, Tool, ToolResult } from '../types';

export class MyPlugin implements MCPPlugin {
  name = 'my-plugin';
  version = '1.0.0';
  description = 'æˆ‘çš„è‡ªå®šä¹‰æ’ä»¶';

  // åˆå§‹åŒ–
  async initialize(config: any): Promise<void> {
    console.log(`æ’ä»¶ ${this.name} å·²åˆå§‹åŒ–`);
    // å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œèµ„æºå‡†å¤‡ã€é…ç½®åŠ è½½ç­‰
  }

  // è·å–å·¥å…·åˆ—è¡¨
  getTools(): Tool[] {
    return [
      {
        name: 'plugin_tool_1',
        description: 'æ’ä»¶å·¥å…·1',
        groups: ['plugin', 'public'],
        inputSchema: {
          type: 'object',
          properties: {
            message: { type: 'string' }
          }
        },
        execute: async (args): Promise<ToolResult> => {
          return {
            content: [{ type: 'text', text: `æ’ä»¶å¤„ç†: ${args.message}` }]
          };
        }
      },
      {
        name: 'plugin_tool_2',
        description: 'æ’ä»¶å·¥å…·2',
        groups: ['plugin', 'advanced'],
        inputSchema: {
          type: 'object',
          properties: {
            data: { type: 'string' }
          }
        },
        execute: async (args): Promise<ToolResult> => {
          return {
            content: [{ type: 'text', text: `é«˜çº§å¤„ç†: ${args.data}` }]
          };
        }
      }
    ];
  }

  // æ¸…ç†
  async cleanup(): Promise<void> {
    console.log(`æ’ä»¶ ${this.name} å·²æ¸…ç†`);
    // é‡Šæ”¾èµ„æºã€å…³é—­è¿æ¥ç­‰
  }
}
```

### 2. æ–‡ä»¶æ“ä½œæ’ä»¶ç¤ºä¾‹

```typescript
// src/plugins/file-plugin.ts
import type { MCPPlugin, Tool, ToolResult } from '../types';
import * as fs from 'fs/promises';
import * as path from 'path';

export class FilePlugin implements MCPPlugin {
  name = 'file-plugin';
  version = '1.0.0';
  description = 'æ–‡ä»¶æ“ä½œæ’ä»¶';

  private workDir: string = './plugin-data';

  async initialize(config: any): Promise<void> {
    // åˆ›å»ºå·¥ä½œç›®å½•
    try {
      await fs.mkdir(this.workDir, { recursive: true });
      console.log(`æ–‡ä»¶æ’ä»¶å·¥ä½œç›®å½•: ${this.workDir}`);
    } catch (error) {
      console.error('åˆå§‹åŒ–å¤±è´¥:', error);
    }
  }

  getTools(): Tool[] {
    return [
      {
        name: 'plugin_file_read',
        description: 'è¯»å–æ’ä»¶æ–‡ä»¶',
        groups: ['plugin', 'file-io'],
        inputSchema: {
          type: 'object',
          properties: {
            filename: { type: 'string', description: 'æ–‡ä»¶å' }
          },
          required: ['filename']
        },
        execute: async (args): Promise<ToolResult> => {
          try {
            const filePath = path.join(this.workDir, args.filename);
            const content = await fs.readFile(filePath, 'utf-8');
            return {
              content: [{ type: 'text', text: content }]
            };
          } catch (error) {
            return {
              content: [{ type: 'text', text: `è¯»å–å¤±è´¥: ${error.message}` }],
              isError: true
            };
          }
        }
      },
      {
        name: 'plugin_file_write',
        description: 'å†™å…¥æ’ä»¶æ–‡ä»¶',
        groups: ['plugin', 'file-io'],
        inputSchema: {
          type: 'object',
          properties: {
            filename: { type: 'string' },
            content: { type: 'string' }
          },
          required: ['filename', 'content']
        },
        execute: async (args): Promise<ToolResult> => {
          try {
            const filePath = path.join(this.workDir, args.filename);
            await fs.writeFile(filePath, args.content, 'utf-8');
            return {
              content: [{ type: 'text', text: `æ–‡ä»¶ ${args.filename} å·²å†™å…¥` }]
            };
          } catch (error) {
            return {
              content: [{ type: 'text', text: `å†™å…¥å¤±è´¥: ${error.message}` }],
              isError: true
            };
          }
        }
      },
      {
        name: 'plugin_file_list',
        description: 'åˆ—å‡ºæ’ä»¶æ–‡ä»¶',
        groups: ['plugin', 'public'],
        inputSchema: {
          type: 'object',
          properties: {}
        },
        execute: async (): Promise<ToolResult> => {
          try {
            const files = await fs.readdir(this.workDir);
            return {
              content: [{ type: 'text', text: `æ–‡ä»¶åˆ—è¡¨:\n${files.join('\n')}` }]
            };
          } catch (error) {
            return {
              content: [{ type: 'text', text: `è¯»å–å¤±è´¥: ${error.message}` }],
              isError: true
            };
          }
        }
      }
    ];
  }

  async cleanup(): Promise<void> {
    // æ¸…ç†ä¸´æ—¶æ–‡ä»¶ç­‰
    console.log(`æ–‡ä»¶æ’ä»¶ ${this.name} å·²æ¸…ç†`);
  }
}
```

### 3. æ•°æ®å¤„ç†æ’ä»¶ç¤ºä¾‹

```typescript
// src/plugins/data-plugin.ts
import type { MCPPlugin, Tool, ToolResult } from '../types';

export class DataPlugin implements MCPPlugin {
  name = 'data-plugin';
  version = '1.0.0';
  description = 'æ•°æ®å¤„ç†æ’ä»¶';

  getTools(): Tool[] {
    return [
      {
        name: 'plugin_data_filter',
        description: 'æ•°æ®è¿‡æ»¤',
        groups: ['plugin', 'data-group'],
        inputSchema: {
          type: 'object',
          properties: {
            data: { type: 'array', items: { type: 'any' } },
            field: { type: 'string' },
            value: { type: 'string' }
          },
          required: ['data', 'field', 'value']
        },
        execute: async (args): Promise<ToolResult> => {
          const filtered = args.data.filter(item => 
            item[args.field] === args.value
          );
          return {
            content: [{ type: 'text', text: JSON.stringify(filtered, null, 2) }]
          };
        }
      },
      {
        name: 'plugin_data_transform',
        description: 'æ•°æ®è½¬æ¢',
        groups: ['plugin', 'data-group'],
        inputSchema: {
          type: 'object',
          properties: {
            data: { type: 'array', items: { type: 'any' } },
            operation: { type: 'string', enum: ['upper', 'lower', 'reverse'] }
          },
          required: ['data', 'operation']
        },
        execute: async (args): Promise<ToolResult> => {
          let transformed = args.data;
          switch (args.operation) {
            case 'upper':
              transformed = args.data.map(item => 
                typeof item === 'string' ? item.toUpperCase() : item
              );
              break;
            case 'lower':
              transformed = args.data.map(item => 
                typeof item === 'string' ? item.toLowerCase() : item
              );
              break;
            case 'reverse':
              transformed = [...args.data].reverse();
              break;
          }
          return {
            content: [{ type: 'text', text: JSON.stringify(transformed, null, 2) }]
          };
        }
      }
    ];
  }
}
```

## ğŸ”Œ æ’ä»¶æ³¨å†Œå’Œä½¿ç”¨

### 1. æ³¨å†Œæ’ä»¶

```typescript
// src/index.ts
import { MyPlugin } from './plugins/my-plugin.js';
import { FilePlugin } from './plugins/file-plugin.js';
import { DataPlugin } from './plugins/data-plugin.js';

class MCPFramework {
  private pluginManager: Map<string, MCPPlugin> = new Map();

  // æ³¨å†Œæ’ä»¶
  async registerPlugin(plugin: MCPPlugin, config?: any): Promise<void> {
    try {
      // åˆå§‹åŒ–æ’ä»¶
      if (plugin.initialize) {
        await plugin.initialize(config);
      }

      // æ³¨å†Œåˆ°ç®¡ç†å™¨
      this.pluginManager.set(plugin.name, plugin);

      // æ³¨å†Œæ’ä»¶å·¥å…·
      if (plugin.getTools) {
        const tools = plugin.getTools();
        tools.forEach(tool => {
          // æ ¹æ®å·¥å…·groupså†³å®šæ³¨å†Œåˆ°å“ªä¸ªå®¹å™¨
          if (tool.groups.includes('plugin')) {
            this.extendedToolSet.register(tool);
          } else if (tool.groups.includes('advanced')) {
            this.advancedToolSet.register(tool);
          } else {
            this.basicToolSet.register(tool);
          }
        });
      }

      console.log(`âœ… æ’ä»¶ ${plugin.name} v${plugin.version} æ³¨å†ŒæˆåŠŸ`);
    } catch (error) {
      console.error(`âŒ æ’ä»¶ ${plugin.name} æ³¨å†Œå¤±è´¥:`, error);
    }
  }

  // åˆå§‹åŒ–æ‰€æœ‰æ’ä»¶
  async initializePlugins(): Promise<void> {
    const plugins = [
      new MyPlugin(),
      new FilePlugin(),
      new DataPlugin()
    ];

    for (const plugin of plugins) {
      await this.registerPlugin(plugin, {});
    }
  }

  // å¸è½½æ’ä»¶
  async unregisterPlugin(pluginName: string): Promise<void> {
    const plugin = this.pluginManager.get(pluginName);
    if (!plugin) {
      throw new Error(`æ’ä»¶ ${pluginName} ä¸å­˜åœ¨`);
    }

    // æ¸…ç†æ’ä»¶
    if (plugin.cleanup) {
      await plugin.cleanup();
    }

    // ç§»é™¤å·¥å…·
    if (plugin.getTools) {
      const tools = plugin.getTools();
      tools.forEach(tool => {
        this.basicToolSet.unregister(tool.name);
        this.advancedToolSet.unregister(tool.name);
        this.extendedToolSet.unregister(tool.name);
      });
    }

    // ä»ç®¡ç†å™¨ç§»é™¤
    this.pluginManager.delete(pluginName);
    console.log(`âœ… æ’ä»¶ ${pluginName} å·²å¸è½½`);
  }

  // è·å–æ’ä»¶åˆ—è¡¨
  getPluginList(): Array<{ name: string; version: string; description: string }> {
    return Array.from(this.pluginManager.values()).map(plugin => ({
      name: plugin.name,
      version: plugin.version,
      description: plugin.description
    }));
  }
}
```

### 2. æ’ä»¶é…ç½®ç®¡ç†

```typescript
// æ’ä»¶é…ç½®ç¤ºä¾‹
const pluginConfigs = {
  'file-plugin': {
    workDir: './plugin-data',
    maxFileSize: 1024 * 1024,
    allowedExtensions: ['.txt', '.json', '.md']
  },
  'data-plugin': {
    maxDataSize: 1000,
    allowedOperations: ['filter', 'transform', 'aggregate']
  },
  'my-plugin': {
    customSetting: 'value'
  }
};

// æ³¨å†Œå¸¦é…ç½®çš„æ’ä»¶
for (const [pluginName, config] of Object.entries(pluginConfigs)) {
  let plugin: MCPPlugin;
  
  switch (pluginName) {
    case 'file-plugin':
      plugin = new FilePlugin();
      break;
    case 'data-plugin':
      plugin = new DataPlugin();
      break;
    case 'my-plugin':
      plugin = new MyPlugin();
      break;
    default:
      continue;
  }
  
  await framework.registerPlugin(plugin, config);
}
```

## ğŸ§ª æ’ä»¶æµ‹è¯•

### 1. å•å…ƒæµ‹è¯•

```typescript
// test/plugins/my-plugin.test.js
import { MyPlugin } from '../build/plugins/my-plugin.js';

async function testMyPlugin() {
  const plugin = new MyPlugin();
  
  // æµ‹è¯•åˆå§‹åŒ–
  await plugin.initialize({});
  console.log('âœ“ æ’ä»¶åˆå§‹åŒ–æˆåŠŸ');

  // æµ‹è¯•å·¥å…·è·å–
  const tools = plugin.getTools();
  console.log(`âœ“ è·å–åˆ° ${tools.length} ä¸ªå·¥å…·`);

  // æµ‹è¯•å·¥å…·æ‰§è¡Œ
  const tool = tools[0];
  const result = await tool.execute({ message: 'æµ‹è¯•' });
  console.log('âœ“ å·¥å…·æ‰§è¡ŒæˆåŠŸ:', result);

  // æµ‹è¯•æ¸…ç†
  await plugin.cleanup();
  console.log('âœ“ æ’ä»¶æ¸…ç†æˆåŠŸ');
}

testMyPlugin();
```

### 2. é›†æˆæµ‹è¯•

```bash
# æµ‹è¯•æ’ä»¶å·¥å…·
# 1. å¯åŠ¨æœåŠ¡å™¨ï¼ˆè‡ªåŠ¨æ³¨å†Œæ’ä»¶ï¼‰
npm run build && node build/index.js

# 2. æŸ¥çœ‹æ‰€æœ‰å·¥å…·ï¼ˆåŒ…æ‹¬æ’ä»¶å·¥å…·ï¼‰
echo '{"jsonrpc":"2.0","id":1,"method":"tools/list","params":{}}' | node build/index.js

# 3. æ‰§è¡Œæ’ä»¶å·¥å…·
echo '{"jsonrpc":"2.0","id":2,"method":"tools/call","params":{"name":"plugin_tool_1","arguments":{"message":"æµ‹è¯•æ’ä»¶"}}}' | node build/index.js

# 4. æµ‹è¯•æ–‡ä»¶æ’ä»¶
echo '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"plugin_file_write","arguments":{"filename":"test.txt","content":"Hello Plugin"}}}' | node build/index.js

echo '{"jsonrpc":"2.0","id":4,"method":"tools/call","params":{"name":"plugin_file_read","arguments":{"filename":"test.txt"}}}' | node build/index.js

echo '{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"plugin_file_list","arguments":{}}}' | node build/index.js
```

## ğŸ¯ æ’ä»¶å¼€å‘æœ€ä½³å®è·µ

### 1. æ’ä»¶è®¾è®¡åŸåˆ™

```typescript
// âœ… å¥½ï¼šå•ä¸€èŒè´£çš„æ’ä»¶
export class FilePlugin implements MCPPlugin {
  name = 'file-plugin';
  description = 'æ–‡ä»¶æ“ä½œæ’ä»¶';
  
  getTools(): Tool[] {
    // åªåŒ…å«æ–‡ä»¶ç›¸å…³å·¥å…·
    return [
      { name: 'file_read', ... },
      { name: 'file_write', ... },
      { name: 'file_delete', ... }
    ];
  }
}

// âŒ åï¼šåŠŸèƒ½æ··æ‚çš„æ’ä»¶
export class MixedPlugin implements MCPPlugin {
  name = 'mixed-plugin';
  description = 'æ··åˆæ’ä»¶';
  
  getTools(): Tool[] {
    return [
      { name: 'file_read', ... },      // æ–‡ä»¶
      { name: 'http_request', ... },   // ç½‘ç»œ
      { name: 'data_filter', ... }     // æ•°æ®
    ];
  }
}
```

### 2. é”™è¯¯å¤„ç†

```typescript
// âœ… å¥½ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†
export class SafePlugin implements MCPPlugin {
  async initialize(config: any): Promise<void> {
    try {
      // éªŒè¯é…ç½®
      if (!config.workDir) {
        throw new Error('ç¼ºå°‘ workDir é…ç½®');
      }
      
      // åˆå§‹åŒ–èµ„æº
      await fs.mkdir(config.workDir, { recursive: true });
    } catch (error) {
      console.error(`æ’ä»¶åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
      throw error; // å‘ä¸ŠæŠ›å‡ºï¼Œè®©è°ƒç”¨è€…å¤„ç†
    }
  }

  getTools(): Tool[] {
    return [
      {
        name: 'safe_tool',
        execute: async (args): Promise<ToolResult> => {
          try {
            // ä¸šåŠ¡é€»è¾‘
            const result = await this.process(args);
            return { content: [{ type: 'text', text: result }] };
          } catch (error) {
            // è¿”å›ç»“æ„åŒ–é”™è¯¯
            return {
              content: [{ type: 'text', text: `é”™è¯¯: ${error.message}` }],
              isError: true,
              structuredContent: {
                errorCode: 'PLUGIN_ERROR',
                details: error.message
              }
            };
          }
        }
      }
    ];
  }
}
```

### 3. èµ„æºç®¡ç†

```typescript
// âœ… å¥½ï¼šå®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
export class ResourcePlugin implements MCPPlugin {
  private connection: any = null;
  private cache: Map<string, any> = new Map();

  async initialize(config: any): Promise<void> {
    // å»ºç«‹è¿æ¥
    this.connection = await this.connect(config);
    console.log('æ’ä»¶èµ„æºå·²åˆå§‹åŒ–');
  }

  getTools(): Tool[] {
    return [
      {
        name: 'cached_tool',
        execute: async (args): Promise<ToolResult> => {
          // ä½¿ç”¨ç¼“å­˜
          const key = JSON.stringify(args);
          if (this.cache.has(key)) {
            return this.cache.get(key);
          }
          
          const result = await this.process(args);
          this.cache.set(key, result);
          return result;
        }
      }
    ];
  }

  async cleanup(): Promise<void> {
    // é‡Šæ”¾èµ„æº
    if (this.connection) {
      await this.connection.close();
      this.connection = null;
    }
    
    // æ¸…ç†ç¼“å­˜
    this.cache.clear();
    console.log('æ’ä»¶èµ„æºå·²é‡Šæ”¾');
  }
}
```

## ğŸ“Š æ’ä»¶ç®¡ç†å·¥å…·

### 1. æ’ä»¶çŠ¶æ€æŸ¥è¯¢

```typescript
// æ·»åŠ æ’ä»¶ç®¡ç†å·¥å…·
const pluginManagementTools: Tool[] = [
  {
    name: 'plugin_list',
    description: 'åˆ—å‡ºå·²å®‰è£…çš„æ’ä»¶',
    groups: ['admin-only', 'plugin-management'],
    inputSchema: { type: 'object', properties: {} },
    execute: async (): Promise<ToolResult> => {
      const plugins = framework.getPluginList();
      return {
        content: [{ 
          type: 'text', 
          text: `å·²å®‰è£…æ’ä»¶ (${plugins.length}):\n${plugins.map(p => 
            `${p.name} v${p.version} - ${p.description}`
          ).join('\n')}` 
        }]
      };
    }
  },
  {
    name: 'plugin_reload',
    description: 'é‡æ–°åŠ è½½æ’ä»¶',
    groups: ['admin-only', 'plugin-management'],
    inputSchema: {
      type: 'object',
      properties: {
        pluginName: { type: 'string' }
      },
      required: ['pluginName']
    },
    execute: async (args): Promise<ToolResult> => {
      try {
        await framework.unregisterPlugin(args.pluginName);
        // é‡æ–°æ³¨å†Œé€»è¾‘
        return {
          content: [{ type: 'text', text: `æ’ä»¶ ${args.pluginName} å·²é‡æ–°åŠ è½½` }]
        };
      } catch (error) {
        return {
          content: [{ type: 'text', text: `é‡æ–°åŠ è½½å¤±è´¥: ${error.message}` }],
          isError: true
        };
      }
    }
  }
];
```

## ğŸ“š ç›¸å…³æ–‡æ¡£

- **å·¥å…·å¼€å‘**ï¼š[01_å·¥å…·å¼€å‘åŸºç¡€.md](01_å·¥å…·å¼€å‘åŸºç¡€.md)
- **é…ç½®ç³»ç»Ÿ**ï¼š[04_é…ç½®ç³»ç»Ÿä½¿ç”¨.md](04_é…ç½®ç³»ç»Ÿä½¿ç”¨.md)
- **æ‰§è¡Œå™¨æ¡†æ¶**ï¼š[07_æ‰§è¡Œå™¨æ¡†æ¶ä½¿ç”¨æŒ‡å—.md](07_æ‰§è¡Œå™¨æ¡†æ¶ä½¿ç”¨æŒ‡å—.md)

---

**ä¸‹ä¸€æ­¥**: å­¦ä¹  [07_æ‰§è¡Œå™¨æ¡†æ¶ä½¿ç”¨æŒ‡å—.md](07_æ‰§è¡Œå™¨æ¡†æ¶ä½¿ç”¨æŒ‡å—.md)